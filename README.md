# Название курса

_All happy databases are alike; each unhappy database is unhappy in its own way_

– Leo Tolstoy? , Anna Concurrenina

---

## Лекции

Презентации лекций располагаются в папке `lectures`

- Distributed system definition
- Consistency models
- Distributed system testing [Jepsen & Maelstrom]
- CRDT (Greg)
- Consensus Intro [Reliable broadcast & FLP & Quorum systems]
- Consensus [Single and multi decree Paxos]
- Consensus [RAFT]
- Transactions
- Byzantine faults ?
- Blockchains (Илья) ?

---

## Задачи

- Echo!
- Timestamp Oracle
- Broadcast
- ...

Если задача имеет несколько профилей. Успешная сдача любого, засчитывает успешную сдачу всех предыдущих (профили идут по возрастанию: 1,2,...)

---

## Проектная работа (Consensus)

...

---

## Работа с репозиторием и CI

Пререквизиты:

- Unix-like операционная система (для windows - WSL 1/2 , VirtualBox, etc...)

  NB: Вы можете помочь с нативной поддержкой windows!

- Установленные [docker](https://docs.docker.com/engine/install/), make, [github cli](https://cli.github.com) и тулинг вашего языка программирования локально.
  Несмотря на то, что сборка ваших программ будет производиться в контейнере, разработка - нет (пока).

- Авторизируйтесь через github cli, это потребуется для сдачи задач: `gh auth login`. Следуйте инструкциям по выбору удобного способа авторизации.

### Структура репозитория

```
├── Dockerfile
├── lecture
├── maelstrom
│   ├── doc
│   │   ├── protocol.md
│   │   ├── results.md
│   │   ├── services.md
│   │   └── workloads.md
│   ├── lib
│   │   └── maelstrom.jar
│   └── maelstrom
├── Makefile
├── README.md
└── tasks
    ├── echo
    │   ├── maelstrom.env
    │   └── README.md
    ├── task-2
    │   ├── maelstrom.env
    │   └── README.md
    └── tso
        ├── maelstrom.env
        └── README.md
```

Вам (студентам) можно только добавлять исходный код в папки задач. Редактирование **ЛЮБЫХ** иных существующих файлов **СТРОГО ЗАПРЕЩЕНО**, включая env файлы в папках задач.

### Makefile

Репозиторий управляется через систему сборки `make`.

Доступные переменные:

- `TASK` - название задачи (соответствует имени директории задачи).
- `PROG_LANG` - язык программирования.

  Доступные варианты:
  - `rust`
  - `go`

- `PROFILE` - профиль задачи. Доступные профили можно найти в файле `profiles.yml`.

Доступные target-ы:

- `sim` - собирает программу и запускает тесты задачи.

  Пример:

  ```sh
  make run TASK=echo PROG_LANG=rust PROFILE=1
  ```

- `clean-jepsen` - удаляет артифакты jepsen во всех директориях задач.

- `submit` - сдать задачу на проверку.

- `template` - создать шаблон проекта под задачу

  Пример:

  ```sh
  make template TASK=echo PROG_LANG=rust
  ```

### Сдача задач CI

Для того, чтобы сдать задачу необходимо поместить ваш исходный код решения задачи в ветку `task/${TASK}/${PROG_LANG}/${PROFILE}`. Переменные соответствуют таковым в `make` сборке. Переключитесь на данную ветку, сделайте её push в свой репозиторий, после чего вызовите `make submit`. В открывшемся окне укажите ваши группу и ФИО. Если вы вызвали `make submit` не запушив перед этим ветку, ничего страшного, вам будет предложено это сделать в интерактивном окне. Будет создан пр в репозиторий организации, на котором прогонятся тесты.
Сдача задач с веток, имеющих другое название, **РАБОТАТЬ НЕ БУДЕТ**.

NB: И помните, любой способ обмануть систему проверки, например редактируя yml файлы, карается обнулением задачи безапелляционно.

### Доступные ЯП и шаблоны проектов

Для выполнение задач доступен ограниченные набор ЯП. При этом вы можете использовать **ЛЮБЫЕ** библиотеки. О некоторых из них будет сказано дополнительно.

Доступные ЯП:

- Rust

  Решение задачи разрабатывается в рамках одного crate-а.
  **ЗАПРЕЩАЕТСЯ** использовать кастомные сборки (наличие файла `build.rs`). В качестве асинхронного рантайма рекомендую использовать [tokio](https://tokio.rs). Для абстрагирования от работы с сырым stdin/stdout maelstrom-а существуюет библиотека [maelstrom-rust-node](https://github.com/sitano/maelstrom-rust-node?tab=readme-ov-file).

- Go

  Решение задачи разрабатывается в рамках одного модуля. Для абстрагирования от работы с сырым stdin/stdout maelstrom-а существуют библиотека [maelstrom-go](https://pkg.go.dev/github.com/jepsen-io/maelstrom/demo/go).

NB: О добалении своего ЯП будет сказано в конце.

---

## Теcтирующая система

Для тестирования задач используется система [Maelstrom](https://github.com/jepsen-io/maelstrom), построенная на базе фреймворка [Jepsen](https://github.com/jepsen-io/jepsen).

Во время тестирования Maelstrom создаёт mock-сеть, объединяющую несколько узлов в кластер. Каждый узел в этой сети - это экземпляр вашего исполняемого файла. Узлы общаются между собой и сервиcами Maelstrom посредством простого json-протокола поверх stdin/stdout, описанного в [документации](./maelstrom/doc/protocol.md).

Для симуляции запросов используются внутренние instance-ы клиентов Maelstrom. Во время тестирования они создают поток запросов, соответствующий [определённому профилю](./maelstrom/doc/workloads.md).

Maelstrom будет пытаться всячески сломать вашу программу с помощью различных fault-injection-ов, например разрезая сеть на несколько кластеров или создавая таймауты при пересылке сообщений. Точный список fault-injection-ов находится в `.yml` файлах каждой задачи.

По результатам тестирования Maelstrom формирует [папку с артифактами](./maelstrom/doc/results.md), включающую текстовое и визуальное описание произошедшего во время тестирования вашего кластера.

По плану курса будет отдельная лекция, посвящённая тестированию распределённых систем, в рамках которой мы поближе познакомимся с этой системой.

NB: Jepsen выводит свои логи в синтаксисе [clojure](https://clojure.org/reference/reader), советую ознакомиться с языком.

NB: Для более тесного знакомства c Jepsen, советую начать с [данного сайта](https://jepsen.io)

---

## Добавление своего языка программирования

Если вам чем-то не понравились доступные ЯП, вы можете добавить свой!
Для этого вы создаёте отдельный пр в `main` ветку репозитория со следующими изменениями:

- Описание default template-а для проекта выше в списке доступных ЯП.
- Установка инструментов языка в контейнер `Dockerfile`.
- Добавление языка во **все** условные (`ifeq`) make target-ы в `Makefile`.
- Установка инструменов в CI: файл `./github/workflows/сi.yml`.

Критерии принятия нового языка:

- Решённая задача Echo!, демонстрирующая, что ваши изменения работают. (Перед мержом она убирается, поэтому советую добавлять её в пр отдельным коммитом).
- Работающий `make template`
